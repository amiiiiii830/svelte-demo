/* App.svelte generated by Svelte v4.2.18 */
import {
    SvelteComponent,
    append,
    append_styles,
    attr,
    binding_callbacks,
    destroy_each,
    detach,
    element,
    ensure_array_like,
    init,
    insert,
    listen,
    noop,
    null_to_empty,
    safe_not_equal,
    set_data,
    space,
    text
} from "svelte/internal";

import "svelte/internal/disclose-version";
import Eliza from 'elizabot';
import { beforeUpdate, afterUpdate } from 'svelte';

function add_css(target) {
    append_styles(target, "svelte-1gwbf6r", ".chat.svelte-1gwbf6r.svelte-1gwbf6r{display:flex;flex-direction:column;height:100%;max-width:320px}.scrollable.svelte-1gwbf6r.svelte-1gwbf6r{flex:1 1 auto;border-top:1px solid #eee;margin:0 0 0.5em 0;overflow-y:auto}article.svelte-1gwbf6r.svelte-1gwbf6r{margin:0.5em 0}.user.svelte-1gwbf6r.svelte-1gwbf6r{text-align:right}span.svelte-1gwbf6r.svelte-1gwbf6r{color:black;padding:0.5em 1em;display:inline-block}.eliza.svelte-1gwbf6r span.svelte-1gwbf6r{background-color:#eee;border-radius:1em 1em 1em 0}.user.svelte-1gwbf6r span.svelte-1gwbf6r{background-color:#0074d9;color:white;border-radius:1em 1em 0 1em}");
}

function get_each_context(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[6] = list[i];
    return child_ctx;
}

// (58:2) {#each comments as comment}
function create_each_block(ctx) {
    let article;
    let span;
    let t0_value = /*comment*/ ctx[6].text + "";
    let t0;
    let t1;
    let article_class_value;

    return {
        c() {
            article = element("article");
            span = element("span");
            t0 = text(t0_value);
            t1 = space();
            attr(span, "class", "svelte-1gwbf6r");
            attr(article, "class", article_class_value = "" + (null_to_empty(/*comment*/ ctx[6].author) + " svelte-1gwbf6r"));
        },
        m(target, anchor) {
            insert(target, article, anchor);
            append(article, span);
            append(span, t0);
            append(article, t1);
        },
        p(ctx, dirty) {
            if (dirty & /*comments*/ 2 && t0_value !== (t0_value = /*comment*/ ctx[6].text + "")) set_data(t0, t0_value);

            if (dirty & /*comments*/ 2 && article_class_value !== (article_class_value = "" + (null_to_empty(/*comment*/ ctx[6].author) + " svelte-1gwbf6r"))) {
                attr(article, "class", article_class_value);
            }
        },
        d(detaching) {
            if (detaching) {
                detach(article);
            }
        }
    };
}

function create_fragment(ctx) {
    let div1;
    let h1;
    let t1;
    let div0;
    let t2;
    let input;
    let mounted;
    let dispose;
    let each_value = ensure_array_like(/*comments*/ ctx[1]);
    let each_blocks = [];

    for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    }

    return {
        c() {
            div1 = element("div");
            h1 = element("h1");
            h1.textContent = "Eliza";
            t1 = space();
            div0 = element("div");

            for (let i = 0; i < each_blocks.length; i += 1) {
                each_blocks[i].c();
            }

            t2 = space();
            input = element("input");
            attr(div0, "class", "scrollable svelte-1gwbf6r");
            attr(div1, "class", "chat svelte-1gwbf6r");
        },
        m(target, anchor) {
            insert(target, div1, anchor);
            append(div1, h1);
            append(div1, t1);
            append(div1, div0);

            for (let i = 0; i < each_blocks.length; i += 1) {
                if (each_blocks[i]) {
                    each_blocks[i].m(div0, null);
                }
            }

            /*div0_binding*/ ctx[3](div0);
            append(div1, t2);
            append(div1, input);

            if (!mounted) {
                dispose = listen(input, "keydown", /*handleKeydown*/ ctx[2]);
                mounted = true;
            }
        },
        p(ctx, [dirty]) {
            if (dirty & /*comments*/ 2) {
                each_value = ensure_array_like(/*comments*/ ctx[1]);
                let i;

                for (i = 0; i < each_value.length; i += 1) {
                    const child_ctx = get_each_context(ctx, each_value, i);

                    if (each_blocks[i]) {
                        each_blocks[i].p(child_ctx, dirty);
                    } else {
                        each_blocks[i] = create_each_block(child_ctx);
                        each_blocks[i].c();
                        each_blocks[i].m(div0, null);
                    }
                }

                for (; i < each_blocks.length; i += 1) {
                    each_blocks[i].d(1);
                }

                each_blocks.length = each_value.length;
            }
        },
        i: noop,
        o: noop,
        d(detaching) {
            if (detaching) {
                detach(div1);
            }

            destroy_each(each_blocks, detaching);
            /*div0_binding*/ ctx[3](null);
            mounted = false;
            dispose();
        }
    };
}

function instance($$self, $$props, $$invalidate) {
    let div;
    let autoscroll;

    beforeUpdate(() => {
        autoscroll = div && div.offsetHeight + div.scrollTop > div.scrollHeight - 20;
    });

    afterUpdate(() => {
        if (autoscroll) div.scrollTo(0, div.scrollHeight);
    });

    const eliza = new Eliza();

    let comments = [
        {
            author: 'eliza',
            text: eliza.getInitial()
        }
    ];

    function handleKeydown(event) {
        if (event.key === 'Enter') {
            const text = event.target.value;
            if (!text) return;
            $$invalidate(1, comments = comments.concat({ author: 'user', text }));
            event.target.value = '';
            const reply = eliza.transform(text);

            setTimeout(
                () => {
                    $$invalidate(1, comments = comments.concat({
                        author: 'eliza',
                        text: '...',
                        placeholder: true
                    }));

                    setTimeout(
                        () => {
                            $$invalidate(1, comments = comments.filter(comment => !comment.placeholder).concat({ author: 'eliza', text: reply }));
                        },
                        500 + Math.random() * 500
                    );
                },
                200 + Math.random() * 200
            );
        }
    }

    function div0_binding($$value) {
        binding_callbacks[$$value ? 'unshift' : 'push'](() => {
            div = $$value;
            $$invalidate(0, div);
        });
    }

    return [div, comments, handleKeydown, div0_binding];
}

class App extends SvelteComponent {
    constructor(options) {
        super();
        init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);
    }
}

const app = new App({
    target: document.getElementById('app')
});

export default app;

